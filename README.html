<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="README_files/libs/clipboard/clipboard.min.js"></script>
<script src="README_files/libs/quarto-html/quarto.js"></script>
<script src="README_files/libs/quarto-html/popper.min.js"></script>
<script src="README_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="README_files/libs/quarto-html/anchor.min.js"></script>
<link href="README_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="README_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="README_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="README_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="README_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="modal-logic-theorem-prover" class="level1">
<h1>Modal Logic Theorem Prover</h1>
<p>This is my <strong>Bachelor thesis at University College London (UCL), supervised by Prof.&nbsp;Robin Hirsch</strong>. It is a <strong>theorem prover</strong> compatible with Modal Logics D, T, B, S4, as well as Linear Modal Logic. This prover was also used to carry out a <strong>study on the validity rate of Modal formulae</strong> with different attributes and constraints.</p>
<p>You will find the my <strong>thesis paper</strong> at <code>paper.pdf</code>, which includes the report on the work you can find on this repository, as well as the validity rate study and other discussions.</p>
<section id="manual" class="level2">
<h2 class="anchored" data-anchor-id="manual">Manual</h2>
<section id="grammar" class="level3">
<h3 class="anchored" data-anchor-id="grammar">Grammar</h3>
<p>This <code>formulaArray</code> prover uses standard Modal Logic syntax. It is recursively defined as the following:</p>
<ul>
<li><span class="math inline">\(\text{prop} = \{a : a \text{ is a string }\}\)</span> &nbsp;<span class="math inline">\(\{b : b \text{ is "T" or "F" or a string such that any of its substrings are ~, [], &lt;&gt;, \&amp;, |, -&gt;, &lt;-&gt;$, $";", ":", ",", ")" or "(" }\}\)</span></li>
<li><span class="math inline">\(\text{fmla} = \text{T | F | prop | ¬fmla | (fmla ∧ fmla) | (fmla ∨ fmla) | (fmla → fmla) | (fmla ↔ fmla) | □fmla | ◊fmla}\)</span></li>
</ul>
<p>Please, make sure you are making use of parentheses correctly, as specified above. The “T” and “F” literals are used to express truth and falsehood. They are not essential, but useful. For example: “T” is equivalent to “(p|~p)”; and “F” is equivalent to “(p&amp;~p)”.</p>
</section>
<section id="syntax" class="level3">
<h3 class="anchored" data-anchor-id="syntax">Syntax</h3>
<p>The syntax you must use when writing your formulas is the following (format: “what you want to write” = “how you should write it”):</p>
<ul>
<li><span class="math inline">\(¬A =\)</span> ~A</li>
<li><span class="math inline">\(□A =\)</span> []A</li>
<li><span class="math inline">\(◊A =\)</span> &lt;&gt;A</li>
<li><span class="math inline">\((A ∧ B) =\)</span> (A &amp; B)</li>
<li><span class="math inline">\((A ∨ B) =\)</span> (A | B)</li>
<li><span class="math inline">\((A → B) =\)</span> (A -&gt; B)</li>
<li><span class="math inline">\((A ↔ B) =\)</span> (A &lt;-&gt; B)</li>
</ul>
<p>You must also note that formulas in a <code>formulaArray</code> are separated by commas (“,”) and different <code>formulaArrays</code> to prove are separated by semicolons (“;”). The last formula in a given <code>formulaArray</code> will be considered as the formula intended to be proven, and all previous formulas of the <code>formulaArray</code> will be considered as axioms. Also, the use of spaces, new tabs, new lines, etc. is irrelevant (but surely helpful for the reader).</p>
</section>
<section id="frame" class="level3">
<h3 class="anchored" data-anchor-id="frame">Frame</h3>
<p>At the beginning of the input file, before any <code>formulaArray</code> has been defined, you may include a Modal System specified by a set of frame conditions which will be applied to the <code>formulaArrays</code> in such input file. If not such system is specified, only the frame condition K will be applied. The frame conditions currently supported by this <code>formulaArray</code> prover are the following:</p>
<ul>
<li>K = Kripke (no special conditions)</li>
<li>T = Reflexive</li>
<li>B = Symmetric</li>
<li>D = Serial</li>
<li>L = Linear</li>
<li>4 = Transitive</li>
</ul>
<p>In order to specify your frame conditions, you may include the following construct (a string of your frame conditions surrounded by colons): <code>:frame_conditions:</code>, where frame_conditions is a string whose only characters are ‘K’, ‘T’, ‘B’, ‘D’ and ‘4’, in any order but without repetition of any of them.</p>
<p>Note that some frame conditions are incompatible. In this version of the program, only L is incompatible with B and D (as serial frames are anti-symmetric and cannot be serial). Also, some frame conditions imply other frame conditions. For example, linearity implies transitivity.</p>
</section>
<section id="usage" class="level3">
<h3 class="anchored" data-anchor-id="usage">Usage</h3>
<p>Create a file called “input.txt” and locate it within the folder “input”. In it, write your <code>formulaArrays</code> as specified above. Next, run the Java program. Finally, find your results in the file “output.txt” in the folder named “output”. If a formula is deemed as “not recognized”, you should check that particular formula as it is not following the syntax and/or grammar specified above. If you are confident your formula is correct, please report any bugs.</p>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>